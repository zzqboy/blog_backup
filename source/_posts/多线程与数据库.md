---
title: 多线程与数据库
date: 2019-04-07 17:39:43
tags: 
	- thread
	- mysql
categories: 技术
---
# 前言
上周写了一个多线程访问数据库的库，在听到隔壁工作室的项目是即时访问数据库后，出于对效率的好奇，打算在这里总结下。
<!-- more -->

# 介绍
本文用的是c++11的thread库，但是大多数的库用起来的差不多，能达到目的就可以。数据库用的mysql，并且是自带的c++api。
源码在这里：[数据库](https://github.com/zzqboy/rpg/blob/master/rpg/rpg/db_work.h)
以及测试代码：[测试](https://github.com/zzqboy/rpg/blob/master/rpg/rpg/test_db.cpp)

# 设计
遵循了大部分的设计，即有一个工作队列，然后一开始设置好线程数，然后这几个线程就以队列为核心开始工作。

在增加任务的时候，也支持增加自定义的参数，这里用到是std::bind的特性。大概是这样用的
```c++
auto fun = std::bind(test_db::task_fun, placeholders::_1);
this->db_work->add_task(fun);
```
只要最后的test_db::task_fun符合声明，那么这里可以像脚本一样传入不定长的参数。

再来看看task_fun:
```c++
void test_db::task_fun(DBWork* db_work)
{
	DataBase* db = db_work->get_database("rpg");
	int col_n = 0;
	char** row;
	DATA_RESULT result = NULL;
	db->execute("select * from role where role_id = 500;", col_n, result);
}
```
这其实就是一个有待多线程去执行的函数，通过唯一参数db_work来执行数据库的操作，sleep是模仿了执行数据库命令后的其余逻辑。
如果说前者是io密集，那么后者就是cpu密集。看来这里的设计变成了一个综合的问题。
下面的是单线程的版本:
```c++
void test_db::test()
{
	int col_n = 0;
	char** row;
	DATA_RESULT result = NULL;
	this->db->execute("select * from role where role_id = 500;", col_n, result);
}
```

# 效率
那么这样一个设计到时是改善了多少呢，这需要测试数据，这里是插入了10000条数据。


|编号|multi-thread|count|time(毫秒)|
|---|---|---|---|
|1|no|100|35|
|2|no|1000|217|
|3|yes|100|17|
|4|yes|1000|190|

# 总结
可以看到，如果数据过多，数据库设计不合理等原因导致数据库执行比较慢，这样确实能提高性能。