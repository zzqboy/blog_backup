---
title: 多线程与数据库
date: 2019-04-07 17:39:43
tags: thread, mysql
categories: 技术
---
# 前言
上周写了一个多线程访问数据库的库，在听到隔壁工作室的项目是即时访问数据库后，出于对效率的好奇，打算在这里总结下。
<!-- more -->

# 介绍
本文用的是c++11的thread库，但是大多数的库用起来的差不多，能达到目的就可以。数据库用的mysql，并且是自带的c++api。
源码在这里：[数据库](https://github.com/zzqboy/rpg/blob/master/rpg/rpg/db_work.h)
以及测试代码：[测试](https://github.com/zzqboy/rpg/blob/master/rpg/rpg/test_db.cpp)

# 设计
遵循了大部分的设计，即有一个工作队列，然后一开始设置好线程数，然后这几个线程就以队列为核心开始工作。

在增加任务的时候，也支持增加自定义的参数，这里用到是std::bind的特性。大概是这样用的
```c++
auto fun = std::bind(test_db::task_fun, placeholders::_1, is_sleep);
this->db_work->add_task(fun);
```
只要最后的test_db::task_fun符合声明，那么这里可以像脚本一样传入不定长的参数。

再来看看task_fun:
```c++
void test_db::task_fun(DBWork* db_work, bool is_sleep)
{
	DataBase* db = db_work->get_database("rpg");
	int col_n = 0;
	char** row;
	DATA_RESULT result = NULL;
	db->execute("select * from role;", col_n, result);
	while (row = GET_RESULT_ROW(result))
	{
		//printf("%s\n", row[0]);
	}
	if (is_sleep)
	{
		Sleep(10);
	}
}
```
这其实就是一个有待多线程去执行的函数，通过唯一参数db_work来执行数据库的操作，sleep是模仿了执行数据库命令后的其余逻辑。
如果说前者是io密集，那么后者就是cpu密集。看来这里的设计变成了一个综合的问题。
下面的是单线程的版本:
```c++
void test_db::test(bool is_sleep)
{
	int col_n = 0;
	char** row;
	DATA_RESULT result = NULL;
	this->db->execute("select * from role;", col_n, result);
	while (row = GET_RESULT_ROW(result))
	{
		//printf("%s\n", row[0]);
	}
	if (is_sleep)
	{
		Sleep(10);
	}
}
```

# 效率
那么这样一个设计到时是改善了多少呢，这需要测试数据。
这里分为有无sleep，也就是探究：单一执行mysql命令，多线程对数据库有帮助否，还是说数据库在io密集上不存在问题

参数说明：
1. sleep:是否增加延时
2. multi-thread:是否多线程
3. count:次数
4. time:结果
(ps:线程数都是12，和cpu核心一样)

|编号|sleep|multi-thread|count|time(毫秒)|
|---|---|---|---|---|
|1|yes|yes|100|89|
|2|yes|yes|1000|914|
|3|yes|yes|5000|4572|
|4|yes|no|100|1010|
|5|yes|no|1000|11003|
|6|yes|no|5000|55041|
|7|no|no|100|25|
|8|no|no|1000|273|
|9|no|no|5000|1382|
|10|no|no|100|33|
|11|no|no|1000|293|
|12|no|no|5000|1459|

# 总结
可以看到，当数据库的命令和上面一样简单的时候，多线程和单线程对于数据库部分的效率差不多。
但是如果命令比较复杂，并且数据库设计不合理等原因导致数据库执行比较慢，达到sleep的效果的话就会增加效率。
PS:（一句话，也就是看mysql语句的执行效率，也说明这种设计起码不会降低效率）